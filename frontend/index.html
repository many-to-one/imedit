<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="main.css">
  <title>Lightroom-style HSL (WebGL1)</title>
  <style>
    body { font-family: sans-serif; background: #222; color: #eee; }

    .main-cont {
      display: flex;
      gap: 10px;
    }

    canvas { border: 1px solid #555; display: block; margin-bottom: 1em; }

    /* .controls { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; } */

    .menuHSL {
      display: flex;
      width: auto;
    }

    .crclHSL {
      width: 30px;
      height: 30px;
      gap: 5px;
      border: 1px solid white;
      border-radius: 50%;
    }

    .group { background: #333; padding: 8px; border-radius: 6px; }
    label { display: block; font-size: 0.8em; margin-bottom: 4px; }
    input[type=range] { width: 100%; }
  </style>
</head>
<body>

  <input type="file" id="fileInput"><br>
  
  <div class="main-cont">

    <canvas id="glcanvas" width="800" height="600"></canvas>
    <div id="status">No image</div>

    <div class="menuHSL">
      <!-- <div class="colorHSL"> -->
         <div class="crclHSL"></div>
         <div class="crclHSL"></div>
         <div class="crclHSL"></div>
         <div class="crclHSL"></div>
         <div class="crclHSL"></div>
         <div class="crclHSL"></div>
         <div class="crclHSL"></div>
         <div class="crclHSL"></div>
      <!-- </div> -->
    </div>
    <div class="controls" id="controls"></div>

  </div>

<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl"); // WebGL1

// ---------- Shaders ----------
const vsSrc = `
attribute vec2 a_pos;
attribute vec2 a_uv;
varying vec2 v_uv;
void main() {
  v_uv = a_uv;
  gl_Position = vec4(a_pos, 0.0, 1.0);
}
`;

const fsSrc = `
precision mediump float;
varying vec2 v_uv;
uniform sampler2D u_tex;

// 24 uniforms (8Ã—3)
uniform float u_hue0; uniform float u_sat0; uniform float u_lig0;
uniform float u_hue1; uniform float u_sat1; uniform float u_lig1;
uniform float u_hue2; uniform float u_sat2; uniform float u_lig2;
uniform float u_hue3; uniform float u_sat3; uniform float u_lig3;
uniform float u_hue4; uniform float u_sat4; uniform float u_lig4;
uniform float u_hue5; uniform float u_sat5; uniform float u_lig5;
uniform float u_hue6; uniform float u_sat6; uniform float u_lig6;
uniform float u_hue7; uniform float u_sat7; uniform float u_lig7;

// Helpers: RGB <-> HSL
vec3 rgb2hsl(vec3 c){
  float maxc = max(max(c.r, c.g), c.b);
  float minc = min(min(c.r, c.g), c.b);
  float h = 0.0; float s = 0.0; float l = (maxc + minc) * 0.5;
  if(maxc != minc){
    float d = maxc - minc;
    s = l > 0.5 ? d / (2.0 - maxc - minc) : d / (maxc + minc);
    if(maxc == c.r) h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0);
    else if(maxc == c.g) h = (c.b - c.r) / d + 2.0;
    else h = (c.r - c.g) / d + 4.0;
    h /= 6.0;
  }
  return vec3(h, s, l);
}
float hue2rgb(float p, float q, float t){
  if(t < 0.0) t += 1.0;
  if(t > 1.0) t -= 1.0;
  if(t < 1.0/6.0) return p + (q - p) * 6.0 * t;
  if(t < 1.0/2.0) return q;
  if(t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
  return p;
}
vec3 hsl2rgb(vec3 hsl){
  float h=hsl.x, s=hsl.y, l=hsl.z;
  if(s==0.0) return vec3(l);
  float q = l < 0.5 ? l*(1.0+s) : l+s-l*s;
  float p = 2.0*l - q;
  return vec3(
    hue2rgb(p,q,h+1.0/3.0),
    hue2rgb(p,q,h),
    hue2rgb(p,q,h-1.0/3.0)
  );
}

// Band selector
void getAdjustments(int band, out float hueShift, out float satScale, out float ligScale){
  if(band==0){hueShift=u_hue0; satScale=u_sat0; ligScale=u_lig0;}
  else if(band==1){hueShift=u_hue1; satScale=u_sat1; ligScale=u_lig1;}
  else if(band==2){hueShift=u_hue2; satScale=u_sat2; ligScale=u_lig2;}
  else if(band==3){hueShift=u_hue3; satScale=u_sat3; ligScale=u_lig3;}
  else if(band==4){hueShift=u_hue4; satScale=u_sat4; ligScale=u_lig4;}
  else if(band==5){hueShift=u_hue5; satScale=u_sat5; ligScale=u_lig5;}
  else if(band==6){hueShift=u_hue6; satScale=u_sat6; ligScale=u_lig6;}
  else {hueShift=u_hue7; satScale=u_sat7; ligScale=u_lig7;}
}

void main(){
  vec4 tex = texture2D(u_tex, v_uv);
  vec3 hsl = rgb2hsl(tex.rgb);

  int band = int(floor(hsl.x * 8.0)); // 0..7
  float hueShift, satScale, ligScale;
  getAdjustments(band, hueShift, satScale, ligScale);

  hsl.x = fract(hsl.x + hueShift/360.0);
  hsl.y = clamp(hsl.y * satScale, 0.0, 1.0);
  hsl.z = clamp(hsl.z * ligScale, 0.0, 1.0);

  vec3 rgb = hsl2rgb(hsl);
  gl_FragColor = vec4(rgb, tex.a);
}
`;

// ---------- Compile & Link ----------
function compile(type, src){
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
    throw new Error(gl.getShaderInfoLog(sh));
  }
  return sh;
}
function program(vs, fs){
  const p = gl.createProgram();
  gl.attachShader(p, vs); gl.attachShader(p, fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
    throw new Error(gl.getProgramInfoLog(p));
  }
  return p;
}
const prog = program(compile(gl.VERTEX_SHADER, vsSrc), compile(gl.FRAGMENT_SHADER, fsSrc));
gl.useProgram(prog);

// ---------- Quad ----------
const quad = new Float32Array([
  -1,-1, 0,0,
   1,-1, 1,0,
  -1, 1, 0,1,
   1, 1, 1,1
]);
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
const a_pos = gl.getAttribLocation(prog,"a_pos");
const a_uv  = gl.getAttribLocation(prog,"a_uv");
gl.enableVertexAttribArray(a_pos);
gl.enableVertexAttribArray(a_uv);
gl.vertexAttribPointer(a_pos,2,gl.FLOAT,false,16,0);
gl.vertexAttribPointer(a_uv,2,gl.FLOAT,false,16,8);

// ---------- Uniforms ----------
const uniforms = {};
function getUniforms(){
  for(let i=0;i<8;i++){
    uniforms[`hue${i}`] = gl.getUniformLocation(prog,`u_hue${i}`);
    uniforms[`sat${i}`] = gl.getUniformLocation(prog,`u_sat${i}`);
    uniforms[`lig${i}`] = gl.getUniformLocation(prog,`u_lig${i}`);
  }
}
getUniforms();

let tex=null;
function setTextureFromImageBitmap(bmp){
  canvas.width=800; canvas.height=600;
  gl.viewport(0,0,canvas.width,canvas.height);
  if(!tex) tex=gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,bmp);
  draw();
}

function draw(){
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.uniform1i(gl.getUniformLocation(prog,"u_tex"),0);
  for(let i=0;i<8;i++){
    gl.uniform1f(uniforms[`hue${i}`], Number(sliders[i].hue.value));
    gl.uniform1f(uniforms[`sat${i}`], Number(sliders[i].sat.value));
    gl.uniform1f(uniforms[`lig${i}`], Number(sliders[i].lig.value));
  }
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
}

// ---------- UI ----------
const fileInput=document.getElementById("fileInput");
const statusEl=document.getElementById("status");
fileInput.addEventListener("change",async()=>{
  const f=fileInput.files?.[0]; if(!f) return;
  const bmp=await createImageBitmap(f,{premultiplyAlpha:"default"});
  setTextureFromImageBitmap(bmp);
  statusEl.textContent="Image loaded";
});

// Generate sliders
const controls=document.getElementById("controls");
const colorNames = ["red","orange","yellow","green","aqua","blue","purple","magenta"];
const bandNames=["Red","Orange","Yellow","Green","Aqua","Blue","Purple","Magenta"];

const circlesHSL=[];
const sliders=[];

for(let i=0;i<8;i++){

  // const c = document.createElement("div");
  // c.className = "crclHSL";
  // c.style.color = colorNames[i];
  // c.style.border = `1px`;
  // c.style.borderColor = `white`;
  // c.style.borderRadius = `50%`;

  const g=document.createElement("div"); g.className="group";
  g.innerHTML=`<b>${bandNames[i]}</b><br>
    Hue <input type="range" min="-180" max="180" step="1" value="0"><br>
    Sat <input type="range" min="0" max="2" step="0.01" value="1"><br>
    Light <input type="range" min="0" max="2" step="0.01" value="1">`;
  controls.appendChild(g);
  const [h,s,l]=g.querySelectorAll("input");
  sliders.push({hue:h,sat:s,lig:l});
  [h,s,l].forEach(inp=>inp.addEventListener("input",()=>{if(tex)draw();}));
}
</script>
</body>
</html>
