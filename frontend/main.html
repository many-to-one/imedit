<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="main.css">
  <title>Lightroom-style HSL (WebGL1)</title>
  <style>
    body { font-family: sans-serif; background: #222; color: #eee; }

    .main-cont {
      display: flex;
      gap: 10px;
    }

    .horisontal-flex {
      display: flex;
      gap: 5px;
    }

    /* canvas { border: 1px solid #555; display: block; margin-bottom: 1em; } */
    canvas {
      border: 1px solid #555;
      display: block;
      margin-bottom: 1em;
      max-width: 80vw;   /* responsive shrink if window is small */
      height: auto;      /* keep aspect ratio */
      object-fit: contain;
    }

    /* .controls { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; } */

    .menuHSL {
      display: flex;
      width: auto;
      gap: 5px;
    }

    .colorPanel {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .crclHSL {
      width: 30px;
      height: 30px;
      gap: 5px;
      border: 1px solid white;
      border-radius: 50%;
      cursor: pointer;
    }

    .group { background: #333; padding: 8px; border-radius: 6px; }

    #calib-title {margin:0 0 8px 0; font-size:14px;}
    #calibration-panel {
      margin: 0 0 8px 0;
      font-size: 14px;
      background-color: silver;
      padding: 5px;
      color: black;
      cursor: pointer;
    }
    #calibration-panel fieldset { border:1px solid #444; padding:8px; margin-bottom:8px; }
    #calibration-panel legend { padding:0 6px; font-weight:bold; }
    #calibration-panel label { display:block; font-size:12px; margin-top:8px; color:#ddd; }
    #calibration-panel input[type=range] { width:100%; }
    #calibration-panel .prim { margin-top:8px; padding-top:8px; border-top:1px dashed #3a3a3a; }
    #calibration-panel .val { font-size:11px; color:#9ad; margin-bottom:6px; }

    label { display: block; font-size: 0.8em; margin-bottom: 4px; }
    input[type=range] { width: 100%; }
  </style>
</head>
<body>

  <input type="file" id="fileInput"><br>
  
  <div class="main-cont">

    <canvas id="glcanvas" width="800" height="600"></canvas>
    <div id="status">No image</div>

    <div class="menuHSL">

      <div class="colorPanel">

        <div class="panel">
          <h3>Basic Adjustments</h3>
          <label>Temperature <input type="range" id="temp" min="-100" max="100" value="0">
            <span id="temperatureValue">0</span>
          </label>
          <label>Tint <input type="range" id="tint" min="-100" max="100" value="0">
            <span id="tintValue">0</span>
          </label>
          <label>Exposure <input type="range" id="exposure" min="-2" max="2" step="0.1" value="0">
            <span id="exposureValue">0</span>
          </label>
          <label>Contrast <input type="range" id="contrast" min="-100" max="100" value="0">
            <span id="contrastValue">0</span>
          </label>
          <label>Highlights <input type="range" id="highlights" min="-100" max="100" value="0">
            <span id="highlightsValue">0</span>
          </label>
          <label>Shadows <input type="range" id="shadows" min="-100" max="100" value="0">
            <span id="shadowsValue">0</span>
          </label>
        </div>

        <div class="curve-box">
          <h3>Curve</h3>
          <svg id="curve">
            <path id="curvePath" d="M 0 200 Q 100 100 200 0" />
            <circle cx="0" cy="200" r="6" />
            <circle cx="100" cy="100" r="6" class="draggable" />
            <circle cx="200" cy="0" r="6" />
          </svg>
        </div>

        <!-- Curve panel (simple 3-point parametric controls) -->
      <!-- <div class="card">
        <h3>Tone Curve (3pt)</h3>
        <div class="row">
          <label for="curveShadow">Curve Shadow</label>
          <input id="curveShadow" type="range" min="0" max="1" step="0.01" value="0">
          <div class="value" id="curveShadowVal">0.00</div>
        </div>
        <div class="row">
          <label for="curveMid">Curve Mid</label>
          <input id="curveMid" type="range" min="0" max="1" step="0.01" value="0.5">
          <div class="value" id="curveMidVal">0.50</div>
        </div>
        <div class="row">
          <label for="curveHighlight">Curve Highlight</label>
          <input id="curveHighlight" type="range" min="0" max="1" step="0.01" value="1">
          <div class="value" id="curveHighlightVal">1.00</div>
        </div>
      </div> -->

         <div class="horisontal-flex">
          <div class="crclHSL" id="Red" style="background-color: red;" onclick="showHSL('Red')"></div>
          <div class="crclHSL" id="Orange" style="background-color: orange;" onclick="showHSL('Orange')"></div>
          <div class="crclHSL" id="Yellow" style="background-color: yellow;" onclick="showHSL('Yellow')"></div>
          <div class="crclHSL" id="Green" style="background-color: green;" onclick="showHSL('Green')"></div>
          <div class="crclHSL" id="Aqua" style="background-color: aqua;" onclick="showHSL('Aqua')"></div>
          <div class="crclHSL" id="Blue" style="background-color: blue;" onclick="showHSL('Blue')"></div>
          <div class="crclHSL" id="Purple" style="background-color: purple;" onclick="showHSL('Purple')"></div>
          <div class="crclHSL" id="Magenta" style="background-color: magenta;" onclick="showHSL('Magenta')"></div>
         </div>

         <div class="controls" id="controls"></div>

         <!-- Calibration panel (HTML) -->
        <h3 id="calib-title" onclick="openCalib()">Calibration</h3>
        <div id="calibration-panel" class="group">

          <fieldset>
            <legend>Shadows</legend>
            <label for="shadowHue">Shadow Hue (deg)</label>
            <input id="shadowHue" type="range" min="-180" max="180" step="1" value="0">
            <div class="val" id="shadowHueVal">0</div>

            <label for="shadowTint">Shadow Tint (sat)</label>
            <input id="shadowTint" type="range" min="0" max="2" step="0.01" value="1">
            <div class="val" id="shadowTintVal">1.00</div>
          </fieldset>

          <fieldset>
            <legend>RGB Primaries</legend>

            <div class="prim">
              <strong>Red</strong>
              <label for="redHue">Hue (deg)</label>
              <input id="redHue" type="range" min="-30" max="30" step="0.5" value="0">
              <div class="val" id="redHueVal">0</div>

              <label for="redSat">Sat (scale)</label>
              <input id="redSat" type="range" min="0" max="2" step="0.01" value="1">
              <div class="val" id="redSatVal">1.00</div>
            </div>

            <div class="prim">
              <strong>Green</strong>
              <label for="greenHue">Hue (deg)</label>
              <input id="greenHue" type="range" min="-30" max="30" step="0.5" value="0">
              <div class="val" id="greenHueVal">0</div>

              <label for="greenSat">Sat (scale)</label>
              <input id="greenSat" type="range" min="0" max="2" step="0.01" value="1">
              <div class="val" id="greenSatVal">1.00</div>
            </div>

            <div class="prim">
              <strong>Blue</strong>
              <label for="blueHue">Hue (deg)</label>
              <input id="blueHue" type="range" min="-30" max="30" step="0.5" value="0">
              <div class="val" id="blueHueVal">0</div>

              <label for="blueSat">Sat (scale)</label>
              <input id="blueSat" type="range" min="0" max="2" step="0.01" value="1">
              <div class="val" id="blueSatVal">1.00</div>
            </div>

          </fieldset>
        </div>
        <!--  End of: Calibration panel (HTML) -->

      </div>

    </div>

  </div>

<script>
const canvas = document.getElementById("glcanvas");
canvas.style.transform = "rotate(180deg) scaleX(-1)";
const gl = canvas.getContext("webgl"); // WebGL1

// ---------- Shaders ----------

// Vertex shader
const vsSrc = `
attribute vec2 a_pos;
attribute vec2 a_uv;
varying vec2 v_uv;
void main() {
  v_uv = a_uv;
  gl_Position = vec4(a_pos, 0.0, 1.0);
}
`;

// Fragment shader
const fsSrc = `
precision mediump float;
varying vec2 v_uv;
uniform sampler2D u_tex;

/* Basic adjustments */
uniform float u_exposure;   // stops
uniform float u_contrast;   // -1..+1
uniform float u_highlights; // -1..+1
uniform float u_shadows;    // -1..+1
uniform float u_whites;     // -1..+1
uniform float u_blacks;     // -1..+1

/* Tone curve (3-point) */
uniform float u_curveShadow;
uniform float u_curveMid;
uniform float u_curveHighlight;


// 24 HSL band uniforms (8Ã—3)
uniform float u_hue0; uniform float u_sat0; uniform float u_lig0;
uniform float u_hue1; uniform float u_sat1; uniform float u_lig1;
uniform float u_hue2; uniform float u_sat2; uniform float u_lig2;
uniform float u_hue3; uniform float u_sat3; uniform float u_lig3;
uniform float u_hue4; uniform float u_sat4; uniform float u_lig4;
uniform float u_hue5; uniform float u_sat5; uniform float u_lig5;
uniform float u_hue6; uniform float u_sat6; uniform float u_lig6;
uniform float u_hue7; uniform float u_sat7; uniform float u_lig7;

// Camera calibration uniforms
uniform float u_shadowHue;
uniform float u_shadowTint;
uniform float u_redHue;   uniform float u_redSat;
uniform float u_greenHue; uniform float u_greenSat;
uniform float u_blueHue;  uniform float u_blueSat;

// Helpers: RGB <-> HSL
vec3 rgb2hsl(vec3 c){
  float maxc = max(max(c.r, c.g), c.b);
  float minc = min(min(c.r, c.g), c.b);
  float h = 0.0; float s = 0.0; float l = (maxc + minc) * 0.5;
  if(maxc != minc){
    float d = maxc - minc;
    s = l > 0.5 ? d / (2.0 - maxc - minc) : d / (maxc + minc);
    if(maxc == c.r) h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0);
    else if(maxc == c.g) h = (c.b - c.r) / d + 2.0;
    else h = (c.r - c.g) / d + 4.0;
    h /= 6.0;
  }
  return vec3(h, s, l);
}
float hue2rgb(float p, float q, float t){
  if(t < 0.0) t += 1.0;
  if(t > 1.0) t -= 1.0;
  if(t < 1.0/6.0) return p + (q - p) * 6.0 * t;
  if(t < 1.0/2.0) return q;
  if(t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
  return p;
}
vec3 hsl2rgb(vec3 hsl){
  float h=hsl.x, s=hsl.y, l=hsl.z;
  if(s==0.0) return vec3(l);
  float q = l < 0.5 ? l*(1.0+s) : l+s-l*s;
  float p = 2.0*l - q;
  return vec3(
    hue2rgb(p,q,h+1.0/3.0),
    hue2rgb(p,q,h),
    hue2rgb(p,q,h-1.0/3.0)
  );
}

// HSL band selector
void getAdjustments(int band, out float hueShift, out float satScale, out float ligScale){
  if(band==0){hueShift=u_hue0; satScale=u_sat0; ligScale=u_lig0;}
  else if(band==1){hueShift=u_hue1; satScale=u_sat1; ligScale=u_lig1;}
  else if(band==2){hueShift=u_hue2; satScale=u_sat2; ligScale=u_lig2;}
  else if(band==3){hueShift=u_hue3; satScale=u_sat3; ligScale=u_lig3;}
  else if(band==4){hueShift=u_hue4; satScale=u_sat4; ligScale=u_lig4;}
  else if(band==5){hueShift=u_hue5; satScale=u_sat5; ligScale=u_lig5;}
  else if(band==6){hueShift=u_hue6; satScale=u_sat6; ligScale=u_lig6;}
  else {hueShift=u_hue7; satScale=u_sat7; ligScale=u_lig7;}
}

// small gaussian weight helper
float weightSmooth(float dist, float sigma){
  return exp(-0.5*(dist/sigma)*(dist/sigma));
}
const float RED_HUE = 0.0;
const float GREEN_HUE = 120.0/360.0;
const float BLUE_HUE = 240.0/360.0;
float hueDist(float a, float b){
  float d = abs(a - b);
  return min(d, 1.0 - d);
}

/* simple 3-point curve interpolation */
float applyCurve(float lum) {
  // control points given as uniforms: u_curveShadow (x=0), u_curveMid (x=0.5), u_curveHighlight (x=1)
  // we'll do a smooth interpolation: shadows->mid for lum in [0,0.5], mid->high for lum in (0.5,1]
  if (lum < 0.5) {
    float t = lum / 0.5;
    return mix(u_curveShadow, u_curveMid, t);
  } else {
    float t = (lum - 0.5) / 0.5;
    return mix(u_curveMid, u_curveHighlight, t);
  }
}

void main(){
  vec4 tex = texture2D(u_tex, v_uv);
  vec3 rgb = tex.rgb;
  vec3 hsl = rgb2hsl(rgb);

  // --- Basic global adjustments ---
  rgb *= pow(2.0, u_exposure); // exposure in stops

  // Contrast (pivot around 0.5)
  rgb = (rgb - 0.5) * (1.0 + u_contrast) + 0.5;

  // Highlights/Shadows/Whites/Blacks
  float lum = dot(rgb, vec3(0.2126,0.7152,0.0722));

  float hFactor = smoothstep(0.5,1.0,lum);
  rgb -= u_highlights * hFactor;

  float sFactor = 1.0 - smoothstep(0.0,0.5,lum);
  rgb += u_shadows * sFactor;

  rgb += u_whites * smoothstep(0.8,1.0,lum);
  rgb += u_blacks * (1.0 - smoothstep(0.0,0.2,lum));

  // clamp
  rgb = clamp(rgb, 0.0, 1.0);

  // --- Tone Curve (3-point parametric) ---
  float curveY = mix(
    mix(u_curveShadow, u_curveMid, lum*2.0),   // shadows-mid
    mix(u_curveMid, u_curveHighlight, (lum-0.5)*2.0), // mid-high
    step(0.5, lum)
  );
  rgb = mix(rgb, vec3(curveY), 0.25); // blend strength

  // --- HSL per-band
  int band = int(floor(hsl.x * 8.0));
  float hueShift, satScale, ligScale;
  getAdjustments(band, hueShift, satScale, ligScale);
  hsl.x = fract(hsl.x + hueShift/360.0);
  hsl.y = clamp(hsl.y * satScale, 0.0, 1.0);
  hsl.z = clamp(hsl.z * ligScale, 0.0, 1.0);
  rgb = hsl2rgb(hsl);

  // --- Shadows calibration
  // float lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));
  float shadowFactor = smoothstep(0.0, 0.5, 1.0 - lum);
  if (shadowFactor > 0.0001) {
    vec3 sh = rgb2hsl(rgb);
    sh.x = fract(sh.x + (u_shadowHue / 360.0) * shadowFactor);
    sh.y = clamp(sh.y * mix(1.0, u_shadowTint, shadowFactor), 0.0, 1.0);
    rgb = hsl2rgb(sh);
  }

  // --- RGB primaries
  vec3 p = rgb2hsl(rgb);

  float dR = hueDist(p.x, RED_HUE);
  float wR = weightSmooth(dR, 0.08);
  p.x = fract(p.x + (u_redHue / 360.0) * wR);
  p.y = clamp(p.y * mix(1.0, u_redSat, wR), 0.0, 1.0);

  float dG = hueDist(p.x, GREEN_HUE);
  float wG = weightSmooth(dG, 0.08);
  p.x = fract(p.x + (u_greenHue / 360.0) * wG);
  p.y = clamp(p.y * mix(1.0, u_greenSat, wG), 0.0, 1.0);

  float dB = hueDist(p.x, BLUE_HUE);
  float wB = weightSmooth(dB, 0.08);
  p.x = fract(p.x + (u_blueHue / 360.0) * wB);
  p.y = clamp(p.y * mix(1.0, u_blueSat, wB), 0.0, 1.0);

  rgb = hsl2rgb(p);
  gl_FragColor = vec4(rgb, tex.a);
}
`;

// ---------- Compile & Link ----------
function compile(type, src){
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
    throw new Error(gl.getShaderInfoLog(sh));
  }
  return sh;
}
function program(vs, fs){
  const p = gl.createProgram();
  gl.attachShader(p, vs); gl.attachShader(p, fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
    throw new Error(gl.getProgramInfoLog(p));
  }
  return p;
}
const prog = program(compile(gl.VERTEX_SHADER, vsSrc), compile(gl.FRAGMENT_SHADER, fsSrc));
gl.useProgram(prog);

// ---------- Quad ----------
const quad = new Float32Array([
  -1,-1, 0,0,
   1,-1, 1,0,
  -1, 1, 0,1,
   1, 1, 1,1
]);
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
const a_pos = gl.getAttribLocation(prog,"a_pos");
const a_uv  = gl.getAttribLocation(prog,"a_uv");
gl.enableVertexAttribArray(a_pos);
gl.enableVertexAttribArray(a_uv);
gl.vertexAttribPointer(a_pos,2,gl.FLOAT,false,16,0);
gl.vertexAttribPointer(a_uv,2,gl.FLOAT,false,16,8);

// ---------- Uniforms ----------

const basicUniforms = {
  exposure: gl.getUniformLocation(prog, "u_exposure"),
  contrast: gl.getUniformLocation(prog, "u_contrast"),
  highlights: gl.getUniformLocation(prog, "u_highlights"),
  shadows: gl.getUniformLocation(prog, "u_shadows"),
  whites: gl.getUniformLocation(prog, "u_whites"),
  blacks: gl.getUniformLocation(prog, "u_blacks"),
  curveShadow: gl.getUniformLocation(prog, "u_curveShadow"),
  curveMid: gl.getUniformLocation(prog, "u_curveMid"),
  curveHighlight: gl.getUniformLocation(prog, "u_curveHighlight")
};

const uniforms = {};
function getUniforms(){
  for(let i=0;i<8;i++){
    uniforms[`hue${i}`] = gl.getUniformLocation(prog,`u_hue${i}`);
    uniforms[`sat${i}`] = gl.getUniformLocation(prog,`u_sat${i}`);
    uniforms[`lig${i}`] = gl.getUniformLocation(prog,`u_lig${i}`);
  }
}
getUniforms();

// calibration uniforms
const calUniforms = {
  shadowHue: gl.getUniformLocation(prog, "u_shadowHue"),
  shadowTint: gl.getUniformLocation(prog, "u_shadowTint"),
  redHue: gl.getUniformLocation(prog, "u_redHue"),
  redSat: gl.getUniformLocation(prog, "u_redSat"),
  greenHue: gl.getUniformLocation(prog, "u_greenHue"),
  greenSat: gl.getUniformLocation(prog, "u_greenSat"),
  blueHue: gl.getUniformLocation(prog, "u_blueHue"),
  blueSat: gl.getUniformLocation(prog, "u_blueSat")
};

let tex=null;

function setTextureFromImageBitmap(bmp) {
  // Match canvas to image resolution
  canvas.width = bmp.width;
  canvas.height = bmp.height;

  // Resize GL viewport
  gl.viewport(0, 0, canvas.width, canvas.height);

  if (!tex) tex = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bmp);

  draw();
}


/* ---------- State holders (JS) ---------- */
const basicValues = {
  exposure: 0.0, contrast: 0.0,
  highlights: 0.0, shadows: 0.0, whites: 0.0, blacks: 0.0,
  curveShadow: 0.0, curveMid: 0.5, curveHighlight: 1.0
};

function draw(){
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.uniform1i(gl.getUniformLocation(prog,"u_tex"),0);

  gl.uniform1f(basicUniforms.exposure, basicValues.exposure);
  gl.uniform1f(basicUniforms.contrast, basicValues.contrast);
  gl.uniform1f(basicUniforms.highlights, basicValues.highlights);
  gl.uniform1f(basicUniforms.shadows, basicValues.shadows);
  gl.uniform1f(basicUniforms.whites, basicValues.whites);
  gl.uniform1f(basicUniforms.blacks, basicValues.blacks);

  gl.uniform1f(basicUniforms.curveShadow, basicValues.curveShadow);
  gl.uniform1f(basicUniforms.curveMid, basicValues.curveMid);
  gl.uniform1f(basicUniforms.curveHighlight, basicValues.curveHighlight);

  for(let i=0;i<8;i++){
    gl.uniform1f(uniforms[`hue${i}`], Number(sliders[i].hue.value));
    gl.uniform1f(uniforms[`sat${i}`], Number(sliders[i].sat.value));
    gl.uniform1f(uniforms[`lig${i}`], Number(sliders[i].lig.value));
  }

  // calibration uniforms
  gl.uniform1f(calUniforms.shadowHue, calibrationValues.shadowHue);
  gl.uniform1f(calUniforms.shadowTint, calibrationValues.shadowTint);
  gl.uniform1f(calUniforms.redHue, calibrationValues.redHue);
  gl.uniform1f(calUniforms.redSat, calibrationValues.redSat);
  gl.uniform1f(calUniforms.greenHue, calibrationValues.greenHue);
  gl.uniform1f(calUniforms.greenSat, calibrationValues.greenSat);
  gl.uniform1f(calUniforms.blueHue, calibrationValues.blueHue);
  gl.uniform1f(calUniforms.blueSat, calibrationValues.blueSat);

  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
}



/* ---------- Basic controls wiring (classic HTML) ---------- */
function wireBasic(id, field, fmt = v => v.toFixed(2), transform = v => v) {
  const el = document.getElementById(id);
  const valEl = document.getElementById(id + 'Value');
  if(!el) return;
  // init value
  el.value = basicValues[field];
  valEl.textContent = fmt(basicValues[field]);
  el.addEventListener('input', () => {
    const raw = Number(el.value);
    basicValues[field] = transform(raw);
    valEl.textContent = fmt(raw);
    draw();
  });
}

/* map slider ids -> fields in basicValues */
wireBasic('exposure', 'exposure', v => Number(v).toFixed(2), v => v); // stops directly
wireBasic('contrast', 'contrast', v => Number(v).toFixed(2), v => v);
wireBasic('highlights', 'highlights', v => Number(v).toFixed(2), v => v);
wireBasic('shadows', 'shadows', v => Number(v).toFixed(2), v => v);
wireBasic('whites', 'whites', v => Number(v).toFixed(2), v => v);
wireBasic('blacks', 'blacks', v => Number(v).toFixed(2), v => v);

wireBasic('curveShadow','curveShadow', v => Number(v).toFixed(2), v => v);
wireBasic('curveMid','curveMid', v => Number(v).toFixed(2), v => v);
wireBasic('curveHighlight','curveHighlight', v => Number(v).toFixed(2), v => v);


// ---------- HSL UI ----------
const fileInput=document.getElementById("fileInput");
const statusEl=document.getElementById("status");
fileInput.addEventListener("change",async()=>{
  const f=fileInput.files?.[0]; if(!f) return;
  const bmp=await createImageBitmap(f,{premultiplyAlpha:"default"});
  setTextureFromImageBitmap(bmp);
  statusEl.textContent="Image loaded";
});

// Generate sliders
const controls=document.getElementById("controls");
const colorNames = ["red","orange","yellow","green","aqua","blue","purple","magenta"];
const bandNames=["Red","Orange","Yellow","Green","Aqua","Blue","Purple","Magenta"];

const circlesHSL=[];
const sliders=[];

for(let i=0;i<8;i++){

  const g=document.createElement("div"); g.id=`hsl_${bandNames[i]}`; g.className=`group_${bandNames[i]}`; g.style.display="none"
  g.innerHTML=`<b>${bandNames[i]}</b><br>
    Hue <input type="range" min="-180" max="180" step="1" value="0"><br>
    Sat <input type="range" min="0" max="2" step="0.01" value="1"><br>
    Light <input type="range" min="0" max="2" step="0.01" value="1">`;
  controls.appendChild(g);
  const [h,s,l]=g.querySelectorAll("input");
  sliders.push({hue:h,sat:s,lig:l});
  [h,s,l].forEach(inp=>inp.addEventListener("input",()=>{if(tex)draw();}));
}

let globalHSL = null;

function showHSL(color) {
  console.log('Click----', color);

  // Hide the previously shown element
  if (globalHSL !== null) {
    const previousCol = document.getElementById(`hsl_${globalHSL}`);
    if (previousCol) {
      previousCol.style.display = "none";
    }
  }

  // Show the new element
  const col = document.getElementById(`hsl_${color}`);
  if (col) {
    col.style.display = "block";
  }

  // Update the global tracker
  globalHSL = color;
}

// const controlsRoot = document.getElementById("controls");



// --------------------- CALIBRATION --------------------- //

function openCalib () {
  var calib = document.getElementById('calibration-panel');

  if ( calib.style.display === 'block') {
    calib.style.display = 'none';
  } else {
    calib.style.display = 'block';
  }
}
// If calibrationValues wasn't defined yet, define a fallback:
  window.calibrationValues = window.calibrationValues || {
    shadowHue:0, shadowTint:1,
    redHue:0, redSat:1,
    greenHue:0, greenSat:1,
    blueHue:0, blueSat:1
  };

  // helper to wire slider -> calibrationValues + UI label + draw()
  function wire(id, field, fmt = v => v) {
    const el = document.getElementById(id);
    const label = document.getElementById(id + "Val");
    if(!el) return;
    // set initial
    el.value = calibrationValues[field];
    if(label) label.textContent = fmt(calibrationValues[field]);

    el.addEventListener("input", () => {
      const val = Number(el.value);
      calibrationValues[field] = val;
      if(label) label.textContent = fmt(val);
      if(typeof draw === "function") draw();
    });
  }

  // Shadows
  wire("shadowHue", "shadowHue", v => `${v}`);
  wire("shadowTint", "shadowTint", v => v.toFixed(2));

  // Red
  wire("redHue", "redHue", v => `${v}`);
  wire("redSat", "redSat", v => v.toFixed(2));

  // Green
  wire("greenHue", "greenHue", v => `${v}`);
  wire("greenSat", "greenSat", v => v.toFixed(2));

  // Blue
  wire("blueHue", "blueHue", v => `${v}`);
  wire("blueSat", "blueSat", v => v.toFixed(2));


// ------------------------------------ //

</script>
</body>
</html>
