<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Lightroom-style Editor — WebGL + HTML controls</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="stylesheet" href="./css/main.css">
<style>
  :root {
    --bg:#222; --card:#2d2d2d; --muted:#9aa; --accent:#6cf;
  }
  body{margin:12px;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:#eee;display:flex;gap:16px}
  main{flex:1 1 auto;min-width:300px}
  aside{width:360px;max-height:calc(100vh - 24px);overflow:auto}
  .card{background:var(--card);padding:10px;border-radius:8px;margin-bottom:12px}
  .card-img{margin-left: 30%; width: 1000px; height: 1000px;}
  h2{margin:0 0 12px 0}
  canvas{width:100%;height:auto;display:block; transform: rotateX(180deg);}
  /* canvas{width:100%;height:auto;display:block; transform: rotateX(180deg);} */
  .row{display:flex;gap:8px;align-items:center;margin:6px 0}
  .row label{flex:1 1 auto;color:var(--muted);font-size:13px}
  .row input[type=range]{flex:1 1 160px}
  .value{width:56px;text-align:right;color:var(--accent);font-variant-numeric:tabular-nums}
  .group{padding:8px;border-radius:6px;background:#363636;margin-bottom:6px}
  button{background:#444;color:#fff;border:0;padding:6px 8px;border-radius:6px;cursor:pointer}
  button:hover{background:#555}
  @media(max-width:900px){body{flex-direction:column}aside{width:100%;order:2}main{order:1}}

  /* layers */
  .layer-panel {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.layer-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 6px;
  background: #222;
  color: #eee;
  border: 1px solid #444;
  cursor: pointer;
}

.layer-item.active {
  background: #0055ff;
  color: #fff;
}

.layer-thumb {
  width: 40px;
  height: 30px;
  object-fit: cover;
  border: 1px solid #555;
}

.layer-name {
  flex: 1;
  background: transparent;
  border: none;
  color: inherit;
  font-size: 14px;
}

.layer-name:focus {
  outline: none;
  background: #333;
}

.layer-controls {
  display: flex;
  gap: 6px;
}
</style>
</head>
<body>
  <main>
    <h2>Lightroom-like editor (WebGL)</h2>

    <div class="card">
       <!-- <input id="fileInput" type="file"
       accept=".jpg,.jpeg,.png,.webp,.gif,.bmp,.avif,.cr2,.nef,.arw,.dng,.orf,.raf,.rw2"> -->
       <input 
          id="fileInput" 
          type="file" 
          multiple accept=".jpg,.jpeg,.png,.webp,.gif,.bmp,.avif,.cr2,.nef,.arw,.dng,.orf,.raf,.rw2"
        >

      <div id="status" style="font-size:12px;color:var(--muted);margin-top:6px">No image loaded</div>
    </div>


    <div class="card-img" style= "overflow:hidden;">
      <canvas id="glcanvas" width="800" height="600" style="display:block;"></canvas>
    </div>

    <!-- Gallery strip -->
    <div id="gallery" style="display:flex; overflow-x:auto; gap:8px; margin-top:12px;"></div>

  </main>

  <aside>
    <div id="controls">
      <!-- Basic panel -->
      <div class="card">
        <h3>Basic</h3>

        <div class="card">
          <label>Zoom: <span id="zoomVal">100%</span></label>
          <input id="zoomSlider" type="range" min="10" max="300" value="100">
        </div>

        <div class="row">
          <label for="temp">Temperature</label>
          <input id="temp" type="range" min="-2" max="2" step="0.1" value="0">
          <div class="value" id="tempVal">0</div>
        </div>

        <div class="row">
          <label for="tint">Tint</label>
          <input id="tint" type="range" min="-100" max="100" step="1" value="0">
          <div class="value" id="tintVal">0</div>
        </div>

        <div class="row">
          <label for="exposure">Exposure (stops)</label>
          <input id="exposure" type="range" min="-2" max="2" step="0.01" value="0">
          <div class="value" id="exposureVal">0.00</div>
        </div>

        <div class="row">
          <label for="contrast">Contrast</label>
          <input id="contrast" type="range" min="-1" max="1" step="0.01" value="0">
          <div class="value" id="contrastVal">0.00</div>
        </div>

        <div class="row">
          <label for="highlights">Highlights</label>
          <input id="highlights" type="range" min="-1" max="1" step="0.01" value="0">
          <div class="value" id="highlightsVal">0.00</div>
        </div>

        <div class="row">
          <label for="shadows">Shadows</label>
          <input id="shadows" type="range" min="-1" max="1" step="0.01" value="0">
          <div class="value" id="shadowsVal">0.00</div>
        </div>

        <div class="row">
          <label for="whites">Whites</label>
          <input id="whites" type="range" min="-1" max="1" step="0.01" value="0">
          <div class="value" id="whitesVal">0.00</div>
        </div>

        <div class="row">
          <label for="blacks">Blacks</label>
          <input id="blacks" type="range" min="-1" max="1" step="0.01" value="0">
          <div class="value" id="blacksVal">0.00</div>
        </div>
      </div>

      <!-- Curve -->
      <div class="card">
        <h3>Tone Curve (3-pt)</h3>
        <div class="row">
          <label for="curveShadow">Curve Shadow</label>
          <input id="curveShadow" type="range" min="0" max="1" step="0.01" value="0">
          <div class="value" id="curveShadowVal">0.00</div>
        </div>
        <div class="row">
          <label for="curveMid">Curve Mid</label>
          <input id="curveMid" type="range" min="0" max="1" step="0.01" value="0.5">
          <div class="value" id="curveMidVal">0.50</div>
        </div>
        <div class="row">
          <label for="curveHighlight">Curve Highlight</label>
          <input id="curveHighlight" type="range" min="0" max="1" step="0.01" value="1">
          <div class="value" id="curveHighlightVal">1.00</div>
        </div>
      </div>

      <!-- HSL -->
      <div class="card">
        <h3>HSL Bands</h3>
        <div style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:8px">
          <button onclick="showHSL('Red')">Red</button>
          <button onclick="showHSL('Orange')">Orange</button>
          <button onclick="showHSL('Yellow')">Yellow</button>
          <button onclick="showHSL('Green')">Green</button>
          <button onclick="showHSL('Aqua')">Aqua</button>
          <button onclick="showHSL('Blue')">Blue</button>
          <button onclick="showHSL('Purple')">Purple</button>
          <button onclick="showHSL('Magenta')">Magenta</button>
        </div>
        <div id="hslContainer"></div>
      </div>

      <!-- Calibration -->
      <div class="card">
        <h3>Calibration</h3>

        <div class="row">
          <label for="shadowHue">Shadow Hue</label>
          <input id="shadowHue" type="range" min="-180" max="180" step="1" value="0">
          <div class="value" id="shadowHueVal">0</div>
        </div>
        <div class="row">
          <label for="shadowTint">Shadow Tint</label>
          <input id="shadowTint" type="range" min="0" max="2" step="0.01" value="1">
          <div class="value" id="shadowTintVal">1.00</div>
        </div>

        <div style="margin-top:6px;font-size:12px;color:var(--muted)">Primaries</div>

        <div class="row">
          <label for="redHue">Red Hue</label>
          <input id="redHue" type="range" min="-30" max="30" step="0.5" value="0">
          <div class="value" id="redHueVal">0</div>
        </div>
        <div class="row">
          <label for="redSat">Red Sat</label>
          <input id="redSat" type="range" min="0" max="2" step="0.01" value="1">
          <div class="value" id="redSatVal">1.00</div>
        </div>

        <div class="row">
          <label for="greenHue">Green Hue</label>
          <input id="greenHue" type="range" min="-30" max="30" step="0.5" value="0">
          <div class="value" id="greenHueVal">0</div>
        </div>
        <div class="row">
          <label for="greenSat">Green Sat</label>
          <input id="greenSat" type="range" min="0" max="2" step="0.01" value="1">
          <div class="value" id="greenSatVal">1.00</div>
        </div>

        <div class="row">
          <label for="blueHue">Blue Hue</label>
          <input id="blueHue" type="range" min="-30" max="30" step="0.5" value="0">
          <div class="value" id="blueHueVal">0</div>
        </div>
        <div class="row">
          <label for="blueSat">Blue Sat</label>
          <input id="blueSat" type="range" min="0" max="2" step="0.01" value="1">
          <div class="value" id="blueSatVal">1.00</div>
        </div>
      </div>

      <!-- Add Layer -->
      <!-- <div class="card">
        <h3>Layers</h3>
        <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px">
          <label for="layerSelect">Active Layer:</label>
          <select id="layerSelect"></select>
          <button id="addLayerBtn">Add Layer</button>
        </div>
        <div id="layerStatus" style="font-size:12px; color:var(--muted)">No layer selected</div>
      </div> -->
      <div class="card">
        <h3>Layers</h3>
        <div id="layerPanel" class="layer-panel"></div>
        <button id="addLayerBtn">+ Add Layer</button>
      </div>




      <!-- Save -->
      <div class="card">
        <div class="card">
          <input id="filenameInput" type="text" placeholder="Enter filename" />
          <select id="fileTypeSelect">
            <option value="png">PNG (.png)</option>
            <option value="jpeg">JPEG (.jpeg)</option>
            <option value="webp">WebP (.webp)</option>
          </select>
          <button id="saveBtn">Save Image</button>
          <div id="saveStatus" style="font-size:12px;color:var(--muted);margin-top:6px">
            Ready
          </div>
        </div>
      </div>


    </div>
  </aside>



<!-- for .CR2 -->
<!-- <script src="./js/rawwasm.js"></script>   -->
<!-- <script type="module" src="https://cdn.jsdelivr.net/npm/libraw-wasm@0.1.4/dist/libraw.js"></script> -->




<script>

const galleryEl = document.getElementById('gallery');

// Store image metadata
const images = [];
let currentImageIndex = null;
let copiedSettings = null;

// Simulated edit settings
// function getEditSettings(image) {
//   return image.settings || { exposure: 1.0, contrast: 1.0 };
// }


/* ---------- WebGL setup and shader (complete) ---------- */
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl');
if(!gl){ alert('WebGL not supported'); throw new Error('WebGL not supported'); }

/* ---------- Zoom logic with slider ---------- */

const zoomSlider = document.getElementById('zoomSlider'); 
const zoomVal = document.getElementById('zoomVal');

zoomSlider.addEventListener('input', () => {
  const scale = Number(zoomSlider.value) / 100;
  canvas.style.transform = `scale(${scale}) rotateX(180deg)`;
  // canvas.style.transformOrigin = 'top left';
  zoomVal.textContent = `${zoomSlider.value}%`;
});

/* ---------- Zoom logic with mouse scroll and cursor moving ---------- */

canvas.addEventListener('wheel', (event) => {
  if (!event.ctrlKey) return; // Ignore scroll unless Ctrl is held

  event.preventDefault(); // Prevent page zoom or scroll

  const delta = Math.sign(event.deltaY); // -1 for zoom in, 1 for zoom out
  let currentZoom = Number(zoomSlider.value);

  const step = 10;
  currentZoom -= delta * step;

  currentZoom = Math.max(zoomSlider.min, Math.min(zoomSlider.max, currentZoom));

  zoomSlider.value = currentZoom;
  const scale = currentZoom / 100;
  canvas.style.transform = `scale(${scale}) rotateX(180deg)`;
  zoomVal.textContent = `${currentZoom}%`;
});

let isDragging = false;
let startX = 0;
let startY = 0;
let offsetX = 0;
let offsetY = 0;
// const { offsetX, offsetY } = window; // use your stored offsets

canvas.addEventListener('mousedown', (e) => {
  isDragging = true;
  startX = e.clientX;
  startY = e.clientY;
});

canvas.addEventListener('mousemove', (e) => {
  if (!isDragging) return;

  const dx = e.clientX - startX;
  const dy = e.clientY - startY;

  offsetX += dx;
  offsetY += dy;

  startX = e.clientX;
  startY = e.clientY;

  applyTransform();
});

canvas.addEventListener('mouseup', () => {
  isDragging = false;
});

canvas.addEventListener('mouseleave', () => {
  isDragging = false;
});

function applyTransform() {
  const scale = Number(zoomSlider.value) / 100;
  canvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale}) rotateX(180deg)`;
}


// Save logic
const saveStatus = document.getElementById('saveStatus');
const fileTypeSelect = document.getElementById('fileTypeSelect');

async function saveWebGLCanvas(filenameBase = 'canvas-image') {
  const width = canvas.width;
  const height = canvas.height;
  const gl = canvas.getContext('webgl');

  saveStatus.textContent = 'Preparing download…';

  // Read pixels
  const pixels = new Uint8Array(width * height * 4);
  gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

  // Offscreen canvas
  const off = document.createElement('canvas');
  off.width = width;
  off.height = height;
  const ctx = off.getContext('2d');
  const imageData = ctx.createImageData(width, height);
  imageData.data.set(pixels);

  // Flip vertically
  ctx.save();
  ctx.translate(0, height);
  ctx.scale(1, -1);
  ctx.putImageData(imageData, 0, 0);
  ctx.restore();

  // Determine type and extension
  const ext = fileTypeSelect.value; // "png", "jpeg", "webp"
  const mime = `image/${ext}`;
  const filename = `${filenameBase}.${ext}`;

  try {
    const blob = await new Promise(res => off.toBlob(res, mime, 0.92));

    if (window.showSaveFilePicker) {
      try {
        const handle = await window.showSaveFilePicker({
          suggestedName: filename,
          types: [{ description: `${ext.toUpperCase()} Image`, accept: { [mime]: [`.${ext}`] } }]
        });
        const writable = await handle.createWritable();
        await writable.write(blob);
        await writable.close();
        saveStatus.textContent = 'File saved successfully ✔';
        return;
      } catch (err) {
        console.warn('Picker failed, falling back:', err);
      }
    }

    // Fallback: auto-download
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    saveStatus.textContent = 'Download started ⬇';
  } catch (err) {
    console.error('Save failed:', err);
    saveStatus.textContent = 'Save failed ✖';
  }
}

saveBtn.addEventListener('click', () => {
  draw(); // ensure GPU buffer is up to date
  const baseName = filenameInput.value.trim() || 'canvas-image';
  saveWebGLCanvas(baseName);
});






/* Vertex shader */
const vsSrc = `
attribute vec2 a_pos;
attribute vec2 a_uv;
varying vec2 v_uv;
void main() {
  v_uv = a_uv;
  gl_Position = vec4(a_pos, 0.0, 1.0);
}
`;

/* Fragment shader: Basic + Curve + HSL + Calibration */
const fsSrc = `
precision mediump float;
varying vec2 v_uv;
uniform sampler2D u_tex;

/* Basic adjustments */
uniform float u_temp;   // -1..1
uniform float u_tint;   // -1..1
uniform float u_exposure;   // stops (-2..2)
uniform float u_contrast;   // -1..1
uniform float u_highlights; // -1..1
uniform float u_shadows;    // -1..1
uniform float u_whites;     // -1..1
uniform float u_blacks;     // -1..1

/* Curve (3-pt) */
uniform float u_curveShadow;
uniform float u_curveMid;
uniform float u_curveHighlight;

/* HSL bands (8*3) */
uniform float u_hue0; uniform float u_sat0; uniform float u_lig0;
uniform float u_hue1; uniform float u_sat1; uniform float u_lig1;
uniform float u_hue2; uniform float u_sat2; uniform float u_lig2;
uniform float u_hue3; uniform float u_sat3; uniform float u_lig3;
uniform float u_hue4; uniform float u_sat4; uniform float u_lig4;
uniform float u_hue5; uniform float u_sat5; uniform float u_lig5;
uniform float u_hue6; uniform float u_sat6; uniform float u_lig6;
uniform float u_hue7; uniform float u_sat7; uniform float u_lig7;

/* Calibration */
uniform float u_shadowHue;
uniform float u_shadowTint;
uniform float u_redHue; uniform float u_redSat;
uniform float u_greenHue; uniform float u_greenSat;
uniform float u_blueHue; uniform float u_blueSat;

/* Helpers: RGB <-> HSL */
vec3 rgb2hsl(vec3 c){
  float maxc = max(max(c.r,c.g),c.b);
  float minc = min(min(c.r,c.g),c.b);
  float h = 0.0; float s = 0.0; float l = (maxc + minc) * 0.5;
  if(maxc != minc){
    float d = maxc - minc;
    s = l > 0.5 ? d / (2.0 - maxc - minc) : d / (maxc + minc);
    if(maxc == c.r) h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0);
    else if(maxc == c.g) h = (c.b - c.r) / d + 2.0;
    else h = (c.r - c.g) / d + 4.0;
    h /= 6.0;
  }
  return vec3(h,s,l);
}
float hue2rgb(float p, float q, float t){
  if(t < 0.0) t += 1.0;
  if(t > 1.0) t -= 1.0;
  if(t < 1.0/6.0) return p + (q - p) * 6.0 * t;
  if(t < 1.0/2.0) return q;
  if(t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
  return p;
}
vec3 hsl2rgb(vec3 hsl){
  float h=hsl.x, s=hsl.y, l=hsl.z;
  if(s==0.0) return vec3(l);
  float q = l < 0.5 ? l*(1.0+s) : l + s - l*s;
  float p = 2.0*l - q;
  return vec3( hue2rgb(p,q,h+1.0/3.0), hue2rgb(p,q,h), hue2rgb(p,q,h-1.0/3.0) );
}

/* HSL band selector (8 bands) */
void getAdjustments(int band, out float hueShift, out float satScale, out float ligScale){
  if(band==0){hueShift=u_hue0; satScale=u_sat0; ligScale=u_lig0;}
  else if(band==1){hueShift=u_hue1; satScale=u_sat1; ligScale=u_lig1;}
  else if(band==2){hueShift=u_hue2; satScale=u_sat2; ligScale=u_lig2;}
  else if(band==3){hueShift=u_hue3; satScale=u_sat3; ligScale=u_lig3;}
  else if(band==4){hueShift=u_hue4; satScale=u_sat4; ligScale=u_lig4;}
  else if(band==5){hueShift=u_hue5; satScale=u_sat5; ligScale=u_lig5;}
  else if(band==6){hueShift=u_hue6; satScale=u_sat6; ligScale=u_lig6;}
  else {hueShift=u_hue7; satScale=u_sat7; ligScale=u_lig7;}
}

/* small helpers for calibration primaries */
float weightSmooth(float dist, float sigma){ return exp(-0.5*(dist/sigma)*(dist/sigma)); }
const float RED_HUE = 0.0;
const float GREEN_HUE = 120.0/360.0;
const float BLUE_HUE = 240.0/360.0;
float hueDist(float a, float b){
  float d = abs(a - b);
  return min(d, 1.0 - d);
}

/* simple 3-pt curve */
float applyCurve(float lum) {
  if(lum < 0.5) {
    float t = lum / 0.5;
    return mix(u_curveShadow, u_curveMid, t);
  } else {
    float t = (lum - 0.5) / 0.5;
    return mix(u_curveMid, u_curveHighlight, t);
  }
}

void main(){
  vec4 tex = texture2D(u_tex, v_uv);
  vec3 rgb = tex.rgb;

  // ---------- White balance (approx) ----------
  rgb.r *= (1.0 + u_temp * 0.15);
  rgb.b *= (1.0 - u_temp * 0.15);
  rgb.g *= (1.0 + u_tint * 0.06);
  rgb = clamp(rgb, 0.0, 1.0);

  // ---------- Exposure ----------
  rgb *= pow(2.0, u_exposure);

  // ---------- Contrast around 0.5 ----------
  rgb = (rgb - 0.5) * (1.0 + u_contrast) + 0.5;

  // ---------- Local tonal adjustments ----------
  float lum = dot(rgb, vec3(0.2126,0.7152,0.0722));
  float hFactor = smoothstep(0.5, 1.0, lum);       // highlights weight
  float sFactor = 1.0 - smoothstep(0.0, 0.5, lum); // shadows weight

  // Apply highlights/shadows/whites/blacks with scaled influence
  rgb += u_highlights * 0.25 * hFactor;
  rgb += u_shadows   * 0.25 * sFactor;
  rgb += u_whites    * 0.15 * smoothstep(0.8,1.0,lum);
  rgb += u_blacks    * 0.15 * (1.0 - smoothstep(0.0,0.2,lum));

  rgb = clamp(rgb, 0.0, 1.0);

  // ---------- Tone curve (soft blend) ----------
  float curveY = applyCurve(lum);
  rgb = mix(rgb, vec3(curveY), 0.25);

  // ---------- HSL per-band ----------
  vec3 hsl = rgb2hsl(rgb);
  int band = int(floor(hsl.x * 8.0)); // 0..7
  float hueShift, satScale, ligScale;
  getAdjustments(band, hueShift, satScale, ligScale);
  hsl.x = fract(hsl.x + hueShift / 360.0);
  hsl.y = clamp(hsl.y * satScale, 0.0, 1.0);
  hsl.z = clamp(hsl.z * ligScale, 0.0, 1.0);
  rgb = hsl2rgb(hsl);

  // ---------- Shadows calibration ----------
  float lum2 = dot(rgb, vec3(0.2126,0.7152,0.0722));
  float shadowFactor = smoothstep(0.0, 0.5, 1.0 - lum2);
  if(shadowFactor > 0.0001) {
    vec3 sh = rgb2hsl(rgb);
    sh.x = fract(sh.x + (u_shadowHue / 360.0) * shadowFactor);
    sh.y = clamp(sh.y * mix(1.0, u_shadowTint, shadowFactor), 0.0, 1.0);
    rgb = hsl2rgb(sh);
  }

  // ---------- RGB primaries calibration ----------
  vec3 p = rgb2hsl(rgb);
  float dR = hueDist(p.x, RED_HUE); float wR = weightSmooth(dR, 0.08);
  p.x = fract(p.x + (u_redHue / 360.0) * wR);
  p.y = clamp(p.y * mix(1.0, u_redSat, wR), 0.0, 1.0);

  float dG = hueDist(p.x, GREEN_HUE); float wG = weightSmooth(dG, 0.08);
  p.x = fract(p.x + (u_greenHue / 360.0) * wG);
  p.y = clamp(p.y * mix(1.0, u_greenSat, wG), 0.0, 1.0);

  float dB = hueDist(p.x, BLUE_HUE); float wB = weightSmooth(dB, 0.08);
  p.x = fract(p.x + (u_blueHue / 360.0) * wB);
  p.y = clamp(p.y * mix(1.0, u_blueSat, wB), 0.0, 1.0);

  rgb = hsl2rgb(p);

  gl_FragColor = vec4(rgb, tex.a);
}
`;

/* ---------- compile + link helpers ---------- */
function compileShader(type, src){
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
    const msg = gl.getShaderInfoLog(sh);
    console.error("Shader compile error:", msg);
    throw new Error(msg);
  }
  return sh;
}
function linkProgram(vs, fs){
  const p = gl.createProgram();
  gl.attachShader(p, vs); gl.attachShader(p, fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
    const msg = gl.getProgramInfoLog(p);
    console.error("Program link error:", msg);
    throw new Error(msg);
  }
  return p;
}

const prog = linkProgram(compileShader(gl.VERTEX_SHADER, vsSrc), compileShader(gl.FRAGMENT_SHADER, fsSrc));
gl.useProgram(prog);

/* ---------- quad attributes ---------- */
const quad = new Float32Array([
  -1, -1,  0, 0,
   1, -1,  1, 0,
  -1,  1,  0, 1,
   1,  1,  1, 1,
]);
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);

const a_pos = gl.getAttribLocation(prog, "a_pos");
const a_uv  = gl.getAttribLocation(prog, "a_uv");
gl.enableVertexAttribArray(a_pos);
gl.enableVertexAttribArray(a_uv);
gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 16, 0);
gl.vertexAttribPointer(a_uv,  2, gl.FLOAT, false, 16, 8);

/* ---------- uniform locations ---------- */
/* basic */
const basicUniforms = {
  temp: gl.getUniformLocation(prog, "u_temp"),
  tint: gl.getUniformLocation(prog, "u_tint"),
  exposure: gl.getUniformLocation(prog, "u_exposure"),
  contrast: gl.getUniformLocation(prog, "u_contrast"),
  highlights: gl.getUniformLocation(prog, "u_highlights"),
  shadows: gl.getUniformLocation(prog, "u_shadows"),
  whites: gl.getUniformLocation(prog, "u_whites"),
  blacks: gl.getUniformLocation(prog, "u_blacks"),
  curveShadow: gl.getUniformLocation(prog, "u_curveShadow"),
  curveMid: gl.getUniformLocation(prog, "u_curveMid"),
  curveHighlight: gl.getUniformLocation(prog, "u_curveHighlight")
};

/* HSL */
const uniforms = {};
for(let i=0;i<8;i++){
  uniforms[`hue${i}`] = gl.getUniformLocation(prog, `u_hue${i}`);
  uniforms[`sat${i}`] = gl.getUniformLocation(prog, `u_sat${i}`);
  uniforms[`lig${i}`] = gl.getUniformLocation(prog, `u_lig${i}`);
}

/* calibration */
const calUniforms = {
  shadowHue: gl.getUniformLocation(prog, "u_shadowHue"),
  shadowTint: gl.getUniformLocation(prog, "u_shadowTint"),
  redHue: gl.getUniformLocation(prog, "u_redHue"),
  redSat: gl.getUniformLocation(prog, "u_redSat"),
  greenHue: gl.getUniformLocation(prog, "u_greenHue"),
  greenSat: gl.getUniformLocation(prog, "u_greenSat"),
  blueHue: gl.getUniformLocation(prog, "u_blueHue"),
  blueSat: gl.getUniformLocation(prog, "u_blueSat")
};

/* ---------- texture & drawing ---------- */
let tex = null;
function setTextureFromImageBitmap(bmp){
  // match canvas to image resolution for full quality
  canvas.width = bmp.width;
  canvas.height = bmp.height;
  gl.viewport(0,0,canvas.width,canvas.height);

  if(!tex) tex = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, tex);

  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bmp);

  draw();
}

const basicValues = {
  temp: 0.0, tint: 0.0,
  exposure: 0.0, contrast: 0.0,
  highlights: 0.0, shadows: 0.0, whites: 0.0, blacks: 0.0,
  curveShadow: 0.0, curveMid: 0.5, curveHighlight: 1.0
};

const calibrationValues = {
  shadowHue:0, shadowTint:1,
  redHue:0, redSat:1,
  greenHue:0, greenSat:1,
  blueHue:0, blueSat:1
};

/* HSL groups (dynamic) */
const colorNames = ["red","orange","yellow","green","aqua","blue","purple","magenta"];
const bandNames = ["Red","Orange","Yellow","Green","Aqua","Blue","Purple","Magenta"];
const sliders = [];
(function createHSLGroups(){
  const container = document.getElementById('hslContainer');
  for(let i=0;i<8;i++){
    const g = document.createElement('div');
    g.className = 'group';
    g.id = `hsl_${bandNames[i]}`;
    g.style.display = 'none';
    g.innerHTML = `<b>${bandNames[i]}</b>
      <div class="row"><label>Hue</label><input id="hue_${i}" type="range" min="-180" max="180" step="1" value="0"><div class="value" id="hueVal_${i}">0</div></div>
      <div class="row"><label>Sat</label><input id="sat_${i}" type="range" min="0" max="2" step="0.01" value="1"><div class="value" id="satVal_${i}">1.00</div></div>
      <div class="row"><label>Light</label><input id="lig_${i}" type="range" min="0" max="2" step="0.01" value="1"><div class="value" id="ligVal_${i}">1.00</div></div>`;
    container.appendChild(g);
    const hue = document.getElementById(`hue_${i}`);
    const sat = document.getElementById(`sat_${i}`);
    const lig = document.getElementById(`lig_${i}`);
    sliders.push({hue,sat,lig});
    hue.addEventListener('input', ()=>{ document.getElementById(`hueVal_${i}`).textContent = hue.value; draw();});
    sat.addEventListener('input', ()=>{ document.getElementById(`satVal_${i}`).textContent = Number(sat.value).toFixed(2); draw();});
    lig.addEventListener('input', ()=>{ document.getElementById(`ligVal_${i}`).textContent = Number(lig.value).toFixed(2); draw();});
  }
})();
showHSL('Red');

function showHSL(color){
  if(!color) return;
  for(let b of bandNames){
    const el = document.getElementById(`hsl_${b}`);
    if(el) el.style.display = (b===color) ? 'block' : 'none';
  }
}

// /* ---------- draw() sets uniforms and renders ---------- */
// function draw() {
//   if (!tex || currentImageIndex === null) return;
//   const s = images[currentImageIndex].settings;

//   gl.clearColor(0, 0, 0, 1);
//   gl.clear(gl.COLOR_BUFFER_BIT);
//   gl.useProgram(prog);
//   gl.uniform1i(gl.getUniformLocation(prog, "u_tex"), 0);

//   // basic
//   for (const key in s.basic) {
//     gl.uniform1f(basicUniforms[key], s.basic[key]);
//   }

//   // HSL bands
//   for (let i = 0; i < 8; i++) {
//     gl.uniform1f(uniforms[`hue${i}`], s.hsl[i].hue);
//     gl.uniform1f(uniforms[`sat${i}`], s.hsl[i].sat);
//     gl.uniform1f(uniforms[`lig${i}`], s.hsl[i].lig);
//   }

//   // calibration
//   for (const key in s.calibration) {
//     gl.uniform1f(calUniforms[key], s.calibration[key]);
//   }

//   gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
// }


// function draw() {
//   if (!tex || currentImageIndex === null) return;
//   const image = images[currentImageIndex];
//   const layer = image.layers[image.activeLayer];
//   if (layer.visible === false) {
//     gl.clearColor(0, 0, 0, 1);
//     gl.clear(gl.COLOR_BUFFER_BIT);
//     return;
//   }
//   const s = layer.settings;

//   gl.clearColor(0, 0, 0, 1);
//   gl.clear(gl.COLOR_BUFFER_BIT);
//   gl.useProgram(prog);
//   gl.uniform1i(gl.getUniformLocation(prog, "u_tex"), 0);

//   for (const key in s.basic) {
//     gl.uniform1f(basicUniforms[key], s.basic[key]);
//   }

//   for (let i = 0; i < 8; i++) {
//     gl.uniform1f(uniforms[`hue${i}`], s.hsl[i].hue);
//     gl.uniform1f(uniforms[`sat${i}`], s.hsl[i].sat);
//     gl.uniform1f(uniforms[`lig${i}`], s.hsl[i].lig);
//   }

//   for (const key in s.calibration) {
//     gl.uniform1f(calUniforms[key], s.calibration[key]);
//   }

//   gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
// }
function draw() {
  if (!tex || currentImageIndex === null) return;

  const image = images[currentImageIndex];
  const layers = image.layers;

  if (image.layers.length === 0) {
    image.activeLayer = null;
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    return;
  }


  // Find the topmost visible layer
  // const visibleLayer = layers.find(layer => layer.visible);
  const visibleLayer = layers.find(layer => layer.visible !== false);
  if (!visibleLayer) {
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    return;
  }

  const s = visibleLayer.settings;

  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.useProgram(prog);
  gl.uniform1i(gl.getUniformLocation(prog, "u_tex"), 0);

  for (const key in s.basic) {
    gl.uniform1f(basicUniforms[key], s.basic[key]);
  }

  for (let i = 0; i < 8; i++) {
    gl.uniform1f(uniforms[`hue${i}`], s.hsl[i].hue);
    gl.uniform1f(uniforms[`sat${i}`], s.hsl[i].sat);
    gl.uniform1f(uniforms[`lig${i}`], s.hsl[i].lig);
  }

  for (const key in s.calibration) {
    gl.uniform1f(calUniforms[key], s.calibration[key]);
  }

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}






const fileInput = document.getElementById('fileInput');
const statusEl = document.getElementById('status');

fileInput.addEventListener('change', async () => {
  const files = Array.from(fileInput.files);
  if (!files.length) return;

  for (const f of files) {
    const ext = f.name.split('.').pop().toLowerCase();
    statusEl.textContent = `Loading ${f.name}...`;

    try {
      let bmp;

      if (['jpg', 'jpeg', 'png', 'webp'].includes(ext)) {
        bmp = await createImageBitmap(f, { premultiplyAlpha: 'default' });
      } else if (['cr2', 'nef', 'arw', 'dng', 'raf', 'rw2'].includes(ext)) {
        const formData = new FormData();
        formData.append('file', f);

        const res = await fetch('/upload', {
          method: 'POST',
          body: formData
        });

        if (!res.ok) throw new Error('Backend upload failed');

        const data = await res.json();
        const base64Url = data.converted;
        const blob = await fetch(base64Url).then(r => r.blob());
        bmp = await createImageBitmap(blob, { premultiplyAlpha: 'default' });
      } else {
        statusEl.textContent = `Unsupported format: ${f.name}`;
        continue;
      }

      // const image = {
      //   name: f.name,
      //   bmp,
      //   settings: {
      //     basic: { ...defaultBasicValues },
      //     calibration: { ...defaultCalibrationValues },
      //     hsl: Array(8).fill().map(() => ({ hue: 0, sat: 1, lig: 1 }))
      //   }
      // };
      const image = {
        name: f.name,
        bmp,
        layers: [
          {
            name: 'Base',
            visible: true, 
            settings: {
              basic: { ...defaultBasicValues },
              calibration: { ...defaultCalibrationValues },
              hsl: Array(8).fill().map(() => ({ hue: 0, sat: 1, lig: 1 }))
            }
          }
        ],
        activeLayer: 0
      };
      images.push(image);

      addToGallery(images.length - 1);
      statusEl.textContent = `Loaded: ${f.name}`;

      // Auto-select first image if none selected yet
      if (currentImageIndex === null) {
        selectImage(images.length - 1);
      }
    } catch (err) {
      console.error('Upload error:', err);
      statusEl.textContent = `Failed to load ${f.name}`;
    }
  }
});

// let device;
// let uniformBuffer;

const defaultBasicValues = {
  temp: 0.0, tint: 0.0,
  exposure: 0.0, contrast: 0.0,
  highlights: 0.0, shadows: 0.0, whites: 0.0, blacks: 0.0,
  curveShadow: 0.0, curveMid: 0.5, curveHighlight: 1.0
};

const defaultCalibrationValues = {
  shadowHue: 0, shadowTint: 1,
  redHue: 0, redSat: 1,
  greenHue: 0, greenSat: 1,
  blueHue: 0, blueSat: 1
};


// Add thumbnail to gallery
function addToGallery(index) {
  const bmp = images[index].bmp;
  const thumbCanvas = document.createElement('canvas');
  thumbCanvas.width = 80;
  thumbCanvas.height = 60;
  const ctx = thumbCanvas.getContext('2d');
  ctx.drawImage(bmp, 0, 0, thumbCanvas.width, thumbCanvas.height);
  thumbCanvas.toBlob(blob => {
    const img = document.createElement('img');
    img.width = 80;
    img.height = 60;
    img.style.cursor = 'pointer';
    img.style.border = '2px solid transparent';
    img.src = URL.createObjectURL(blob);
    img.onclick = () => selectImage(index);
    galleryEl.appendChild(img);
  }, 'image/png');
}


// Select image
function selectImage(index) {
  currentImageIndex = index;
  const image = images[index];
  const settings = image.settings || {};

  setTextureFromImageBitmap(image.bmp);
  applySettings(settings); // ← apply without overwriting
  draw();
  highlightGallery(index);
  statusEl.textContent = `Selected: ${image.name}`;

  // Restore sliders
  for (const [sliderId, { key, label, format }] of Object.entries(sliderMap)) {
    const slider = document.getElementById(sliderId);
    const labelEl = document.getElementById(label);
    if (!slider || !labelEl) continue;

    const val = settings[key] ?? parseFloat(slider.defaultValue);
    slider.value = val;
    labelEl.textContent = format ? format(val) : val;
  }
}

function applySettings(settings) {

  console.log('applySettings -----', settings)
  // if (!device || !uniformBuffer) {
  //   console.warn('WebGPU device or buffer not ready');
  //   return;
  // }

  const data = new Float32Array([
    settings.exposure ?? 0,
    settings.contrast ?? 0,
    settings.highlights ?? 0,
    settings.shadows ?? 0,
    settings.whites ?? 0,
    settings.blacks ?? 0,
    settings.temperature ?? 0,
    settings.tint ?? 0,
    settings.curveShadow ?? 0,
    settings.curveMid ?? 0.5,
    settings.curveHighlight ?? 1,
    settings.shadowHue ?? 0,
    settings.shadowTint ?? 1,
    settings.redHue ?? 0,
    settings.redSat ?? 1,
    settings.greenHue ?? 0,
    settings.greenSat ?? 1,
    settings.blueHue ?? 0,
    settings.blueSat ?? 1
  ]);

  // device.queue.writeBuffer(uniformBuffer, 0, data);
}


const defaultSettings = {
  zoom: 100,
  temperature: 0,
  tint: 0,
  exposure: 0,
  contrast: 0,
  highlights: 0,
  shadows: 0,
  whites: 0,
  blacks: 0,
  curveShadow: 0,
  curveMid: 0.5,
  curveHighlight: 1,
  shadowHue: 0,
  shadowTint: 1,
  redHue: 0,
  redSat: 1,
  greenHue: 0,
  greenSat: 1,
  blueHue: 0,
  blueSat: 1
};


const sliderMap = {
  zoomSlider:       { panel: 'basic', key: 'zoom',        label: 'zoomVal',        format: v => `${v}%` },
  temp:             { panel: 'basic', key: 'temp',        label: 'tempVal' },
  tint:             { panel: 'basic', key: 'tint',        label: 'tintVal' },
  exposure:         { panel: 'basic', key: 'exposure',    label: 'exposureVal',    format: v => v.toFixed(2) },
  contrast:         { panel: 'basic', key: 'contrast',    label: 'contrastVal',    format: v => v.toFixed(2) },
  highlights:       { panel: 'basic', key: 'highlights',  label: 'highlightsVal',  format: v => v.toFixed(2) },
  shadows:          { panel: 'basic', key: 'shadows',     label: 'shadowsVal',     format: v => v.toFixed(2) },
  whites:           { panel: 'basic', key: 'whites',      label: 'whitesVal',      format: v => v.toFixed(2) },
  blacks:           { panel: 'basic', key: 'blacks',      label: 'blacksVal',      format: v => v.toFixed(2) },
  curveShadow:      { panel: 'basic', key: 'curveShadow', label: 'curveShadowVal', format: v => v.toFixed(2) },
  curveMid:         { panel: 'basic', key: 'curveMid',    label: 'curveMidVal',    format: v => v.toFixed(2) },
  curveHighlight:   { panel: 'basic', key: 'curveHighlight', label: 'curveHighlightVal', format: v => v.toFixed(2) },

  shadowHue:        { panel: 'calibration', key: 'shadowHue',   label: 'shadowHueVal' },
  shadowTint:       { panel: 'calibration', key: 'shadowTint',  label: 'shadowTintVal',  format: v => v.toFixed(2) },
  redHue:           { panel: 'calibration', key: 'redHue',      label: 'redHueVal' },
  redSat:           { panel: 'calibration', key: 'redSat',      label: 'redSatVal',      format: v => v.toFixed(2) },
  greenHue:         { panel: 'calibration', key: 'greenHue',    label: 'greenHueVal' },
  greenSat:         { panel: 'calibration', key: 'greenSat',    label: 'greenSatVal',    format: v => v.toFixed(2) },
  blueHue:          { panel: 'calibration', key: 'blueHue',     label: 'blueHueVal' },
  blueSat:          { panel: 'calibration', key: 'blueSat',     label: 'blueSatVal',     format: v => v.toFixed(2) },
};

// Dynamically add HSL sliders
for (let i = 0; i < 8; i++) {
  sliderMap[`hue_${i}`] = { panel: 'hsl', index: i, key: 'hue', label: `hueVal_${i}` };
  sliderMap[`sat_${i}`] = { panel: 'hsl', index: i, key: 'sat', label: `satVal_${i}`, format: v => v.toFixed(2) };
  sliderMap[`lig_${i}`] = { panel: 'hsl', index: i, key: 'lig', label: `ligVal_${i}`, format: v => v.toFixed(2) };
}


// Slider wiring loop
// for (const [sliderId, config] of Object.entries(sliderMap)) {
//   const slider = document.getElementById(sliderId);
//   const labelEl = document.getElementById(config.label);
//   if (!slider || !labelEl) continue;

//   slider.addEventListener('input', () => {
//     const val = parseFloat(slider.value);
//     labelEl.textContent = config.format ? config.format(val) : val;

//     if (config.panel === 'hsl') {
//       const band = images[currentImageIndex].settings.hsl[config.index];
//       band[config.key] = val;
//     } else {
//       images[currentImageIndex].settings[config.panel][config.key] = val;
//     }

//     draw();
//   });
// }
for (const [sliderId, config] of Object.entries(sliderMap)) {
  const slider = document.getElementById(sliderId);
  const labelEl = document.getElementById(config.label);
  if (!slider || !labelEl) continue;

  slider.addEventListener('input', () => {
    const val = parseFloat(slider.value);
    labelEl.textContent = config.format ? config.format(val) : val;

    const image = images[currentImageIndex];
    const layer = image.layers[image.activeLayer];

    if (config.panel === 'hsl') {
      layer.settings.hsl[config.index][config.key] = val;
    } else {
      layer.settings[config.panel][config.key] = val;
    }

    draw();
  });
}





function updateSetting(panel, key, value) {
  console.log('updateSetting panel ------', panel)
  console.log('updateSetting ------ k, v', key, value)
  if (currentImageIndex !== null) {
    const image = images[currentImageIndex];
    image.settings[panel][key] = value;
    draw();
  }
}
// function updateSetting(panel, key, value) {
//   if (currentImageIndex !== null) {
//     const image = images[currentImageIndex];
//     const layer = image.layers[image.activeLayer];
//     layer.settings[panel][key] = value;
//     draw();
//   }
// }



function restoreSliders(settings) {
  for (const [sliderId, config] of Object.entries(sliderMap)) {
    const slider = document.getElementById(sliderId);
    const labelEl = document.getElementById(config.label);
    if (!slider || !labelEl) continue;

    let val;
    if (config.panel === 'hsl') {
      val = settings.hsl[config.index][config.key];
    } else {
      val = settings[config.panel][config.key];
    }

    slider.value = val;
    labelEl.textContent = config.format ? config.format(val) : val;
  }
}
// function restoreSliders(settings) {
//   for (const [sliderId, config] of Object.entries(sliderMap)) {
//     const slider = document.getElementById(sliderId);
//     const labelEl = document.getElementById(config.label);
//     if (!slider || !labelEl) continue;

//     let val;
//     if (config.panel === 'hsl') {
//       const layer = images[currentImageIndex].layers[images[currentImageIndex].activeLayer];
//       layer.settings.hsl[config.index][config.key] = val;
//     } else {
//       const layer = images[currentImageIndex].layers[images[currentImageIndex].activeLayer];
//       layer.settings[config.panel][config.key] = val;
//     }

//     if (
//       currentImageIndex === null ||
//       !images[currentImageIndex] ||
//       !images[currentImageIndex].layers?.[images[currentImageIndex].activeLayer]
//     ) return;

//     slider.value = val;
//     labelEl.textContent = config.format ? config.format(val) : val;
//   }
// }

// ################################################# LAYERS LOGIC ################################################# //

// const layerSelect = document.getElementById('layerSelect');
const addLayerBtn = document.getElementById('addLayerBtn');
const layerStatus = document.getElementById('layerStatus');
const layerPanel = document.getElementById('layerPanel');


// function addLayer(name = `Layer ${images[currentImageIndex].layers.length + 1}`) {
// console.log('addLayer click ------', name)
//   const image = images[currentImageIndex];
//   image.layers.push({
//     name,
//     settings: {
//       basic: { ...defaultBasicValues },
//       calibration: { ...defaultCalibrationValues },
//       hsl: Array(8).fill().map(() => ({ hue: 0, sat: 1, lig: 1 }))
//     }
//   });
//   image.activeLayer = image.layers.length - 1;
//   updateLayerUI();
//   restoreSliders(image.layers[image.activeLayer].settings);
//   draw();
// }
function addLayer(name = `Layer ${images[currentImageIndex].layers.length + 1}`) {
  const image = images[currentImageIndex];

  image.layers.unshift({
    name,
    visible: true,
    settings: {
      basic: { ...defaultBasicValues },
      calibration: { ...defaultCalibrationValues },
      hsl: Array(8).fill().map(() => ({ hue: 0, sat: 1, lig: 1 }))
    }
  });

  image.activeLayer = 0; // newest layer becomes active
  updateLayerUI();       // re-render layer stack
  restoreSliders(image.layers[0].settings); // update sliders
  draw();                // re-render canvas
}



function switchLayer(index) {
  const image = images[currentImageIndex];
  image.activeLayer = index;
  updateLayerUI();
  restoreSliders(image.layers[index].settings);
  draw();
}


// function updateLayerUI() {
//   const image = images[currentImageIndex];
//   layerSelect.innerHTML = '';
//   image.layers.forEach((layer, i) => {
//     const opt = document.createElement('option');
//     opt.value = i;
//     opt.textContent = layer.name;
//     if (i === image.activeLayer) opt.selected = true;
//     layerSelect.appendChild(opt);
//   });
//   layerStatus.textContent = `Editing: ${image.layers[image.activeLayer].name}`;
// }
function updateLayerUI() {
  const image = images[currentImageIndex];
  layerPanel.innerHTML = '';

  image.layers.forEach((layer, i) => {
    const div = document.createElement('div');
    div.className = 'layer-item' + (i === image.activeLayer ? ' active' : '');
    div.onclick = () => switchLayer(i);

    // Thumbnail
    const thumb = document.createElement('img');
    thumb.className = 'layer-thumb';
    const canvas = document.createElement('canvas');
    canvas.width = 40;
    canvas.height = 30;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(image.bmp, 0, 0, canvas.width, canvas.height);
    canvas.toBlob(blob => {
      thumb.src = URL.createObjectURL(blob);
    }, 'image/png');

    // Editable name
    const nameInput = document.createElement('input');
    nameInput.className = 'layer-name';
    nameInput.value = layer.name;
    nameInput.oninput = (e) => {
      layer.name = e.target.value;
      // updateLayerUI(); // re-render to reflect name
    };
    
    nameInput.onclick = (e) => {
      e.stopPropagation(); // prevent layer switch
    };

    nameInput.onmousedown = (e) => {
      e.stopPropagation(); // prevent parent from hijacking focus
    };

    nameInput.onkeydown = (e) => {
      e.stopPropagation(); // prevent accidental bubbling
    };

    // Controls
    const controls = document.createElement('div');
    controls.className = 'layer-controls';

    const eye = document.createElement('button');
    eye.textContent = layer.visible === false ? '🙈' : '👁️';
    eye.onclick = (e) => {
      e.stopPropagation();
      layer.visible = !layer.visible;
      updateLayerUI();
      draw();
    };

    const del = document.createElement('button');
    del.textContent = '🗑️';
    del.onclick = (e) => {
      e.stopPropagation();
      image.layers.splice(i, 1);
      if (image.activeLayer >= image.layers.length) image.activeLayer = image.layers.length - 1;
      updateLayerUI();
      restoreSliders(image.layers[image.activeLayer].settings);
      draw();
    };

    controls.appendChild(eye);
    controls.appendChild(del);

    div.appendChild(thumb);
    div.appendChild(nameInput);
    div.appendChild(controls);
    layerPanel.appendChild(div);
  });
}




addLayerBtn.addEventListener('click', () => {
  if (currentImageIndex !== null) addLayer();
});
// addLayerBtn.onclick = () => {
//   if (currentImageIndex !== null) addLayer();
//   const image = images[currentImageIndex];
//   const newLayer = {
//     name: `Layer ${image.layers.length + 1}`,
//     visible: true,
//     settings: {
//       basic: { ...defaultBasicValues },
//       calibration: { ...defaultCalibrationValues },
//       hsl: Array(8).fill().map(() => ({ hue: 0, sat: 1, lig: 1 }))
//     }
//   };
//   image.layers.push(newLayer);
//   image.activeLayer = image.layers.length - 1;
//   updateLayerUI();
//   restoreSliders(newLayer.settings);
//   draw();
// };


function selectImage(index) {
  currentImageIndex = index;
  const image = images[index];
  setTextureFromImageBitmap(image.bmp);
  updateLayerUI();
  restoreSliders(image.layers[image.activeLayer].settings);
  draw();
  highlightGallery(index);
  statusEl.textContent = `Selected: ${image.name}`;
}


// ################################################# END LAYERS LOGIC ################################################# //

// Highlight selected thumbnail
function highlightGallery(index) {
  Array.from(galleryEl.children).forEach((el, i) => {
    el.style.border = i === index ? '2px solid #00f' : '2px solid transparent';
  });
}

// Copy/paste settings
function copySettings() {
  if (currentImageIndex !== null) {
    copiedSettings = getEditSettings(images[currentImageIndex]);
    statusEl.textContent = 'Settings copied';
  }
}
function pasteSettings() {
  if (copiedSettings && currentImageIndex !== null) {
    applySettings(images[currentImageIndex], copiedSettings);
    statusEl.textContent = 'Settings pasted';
  }
}

// Keyboard shortcuts (optional)
document.addEventListener('keydown', e => {
  if (e.ctrlKey && e.key === 'c') copySettings();
  if (e.ctrlKey && e.key === 'v') pasteSettings();
});



/* ---------- helpers to wire UI sliders to JS state ---------- */
function wireBasic(id, field, fmt = v => v.toFixed(2), transform = v => v){
  const el = document.getElementById(id);
  const valEl = document.getElementById(id + 'Val');
  if(!el) { console.warn('Missing slider', id); return; }
  if(valEl) valEl.textContent = fmt(basicValues[field]);
  el.addEventListener('input', ()=>{
    const raw = Number(el.value);
    basicValues[field] = transform(raw);
    if(valEl) valEl.textContent = fmt(raw);
    draw();
  });
}

/* map slider ranges => shader domain */
wireBasic('temp', 'temp', v => `${v}`, v => v/100.0);
wireBasic('tint', 'tint', v => `${v}`, v => v/100.0);
wireBasic('exposure', 'exposure', v => Number(v).toFixed(2), v => v);
wireBasic('contrast', 'contrast', v => Number(v).toFixed(2), v => v);
wireBasic('highlights', 'highlights', v => Number(v).toFixed(2), v => v);
wireBasic('shadows', 'shadows', v => Number(v).toFixed(2), v => v);
wireBasic('whites', 'whites', v => Number(v).toFixed(2), v => v);
wireBasic('blacks', 'blacks', v => Number(v).toFixed(2), v => v);

wireBasic('curveShadow', 'curveShadow', v => Number(v).toFixed(2), v => v);
wireBasic('curveMid', 'curveMid', v => Number(v).toFixed(2), v => v);
wireBasic('curveHighlight', 'curveHighlight', v => Number(v).toFixed(2), v => v);

/* ---------- calibration wiring ---------- */
function wireCal(id, field, fmt = v => v.toFixed(2), transform = v => v){
  const el = document.getElementById(id);
  const valEl = document.getElementById(id + 'Val');
  if(!el) { console.warn('Missing calib slider', id); return; }
  if(valEl) valEl.textContent = fmt(calibrationValues[field]);
  el.addEventListener('input', ()=>{
    const raw = Number(el.value);
    calibrationValues[field] = transform(raw);
    if(valEl) valEl.textContent = fmt(raw);
    draw();
  });
}

wireCal('shadowHue','shadowHue', v => `${v}`, v => v);
wireCal('shadowTint','shadowTint', v => Number(v).toFixed(2), v => v);

wireCal('redHue','redHue', v => `${v}`, v => v);
wireCal('redSat','redSat', v => Number(v).toFixed(2), v => v);
wireCal('greenHue','greenHue', v => `${v}`, v => v);
wireCal('greenSat','greenSat', v => Number(v).toFixed(2), v => v);
wireCal('blueHue','blueHue', v => `${v}`, v => v);
wireCal('blueSat','blueSat', v => Number(v).toFixed(2), v => v);

/* ---------- small sanity logs (helpful during dev) ---------- */
console.log('Uniform locations basicUniforms:', basicUniforms);
console.log('HSL uniform map sample:', uniforms.hue0, uniforms.sat0, uniforms.lig0);
console.log('Calibration uniform map sample:', calUniforms.shadowHue, calUniforms.redHue);

/* draw will run automatically when image is set and sliders move */
</script>

<!-- <script type="module">
import * as LibRawModule from "https://cdn.jsdelivr.net/npm/libraw-wasm@1.1.2/dist/index.mjs";

const LibRaw = await LibRawModule.default?.() || LibRawModule.LibRaw?.();

// const canvas = document.getElementById('glcanvas');
// const gl = canvas.getContext('webgl');
// const fileInput = document.getElementById('fileInput');
const status = document.getElementById('status');
let texture = null;
let imageWidth = 0, imageHeight = 0;

fileInput.addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  status.textContent = `Loading ${file.name}...`;

  try {
    const buffer = await file.arrayBuffer();

    if (file.name.toLowerCase().endsWith(".cr2")) {
      const libraw = await LibRaw();
      const raw = libraw.decode(new Uint8Array(buffer));
      const imgData = new Uint8ClampedArray(raw.data);
      imageWidth = raw.width;
      imageHeight = raw.height;

      const imageBitmap = await createImageBitmap(
        new ImageData(imgData, imageWidth, imageHeight)
      );
      uploadToGL(imageBitmap);
      status.textContent = "RAW image loaded successfully.";
    } else {
      const img = new Image();
      img.onload = () => {
        uploadToGL(img);
        status.textContent = "Standard image loaded.";
      };
      img.src = URL.createObjectURL(file);
    }

  } catch (err) {
    console.error(err);
    status.textContent = "Failed to load image.";
  }
});

function uploadToGL(image) {
  canvas.width = image.width;
  canvas.height = image.height;
  imageWidth = image.width;
  imageHeight = image.height;

  if (texture) gl.deleteTexture(texture);
  texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

  draw(); // call your WebGL shader render function
}
</script> -->



</body>
</html>
